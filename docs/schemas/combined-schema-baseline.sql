-- Migration generated by Codex assistant to bootstrap remote schema
-- Combines sql/000_init.sql, sql/001_security_realtime.sql, sql/002_trigger_user_profiles.sql

-- BEGIN 000_init.sql
-- Enable useful extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Helper schema for security-aware functions
CREATE SCHEMA IF NOT EXISTS app_private;

COMMENT ON SCHEMA app_private IS 'Private helper functions for JWT-based access control.';

-- Helper functions to read claims from Supabase JWT
CREATE OR REPLACE FUNCTION app_private.current_tenant_id()
RETURNS uuid
LANGUAGE SQL
STABLE
AS $$
  SELECT
    NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'tenant_id', '')::uuid;
$$;

COMMENT ON FUNCTION app_private.current_tenant_id IS 'Extracts tenant_id from JWT claims (or NULL if absent).';

CREATE OR REPLACE FUNCTION app_private.current_app_role()
RETURNS text
LANGUAGE SQL
STABLE
AS $$
  SELECT
    COALESCE(current_setting('request.jwt.claims', true)::jsonb->>'app_role', 'viewer');
$$;

COMMENT ON FUNCTION app_private.current_app_role IS 'Extracts app-specific role from JWT claims, defaults to viewer.';

CREATE OR REPLACE FUNCTION app_private.current_user_id()
RETURNS uuid
LANGUAGE SQL
STABLE
AS $$
  SELECT NULLIF(current_setting('request.jwt.claims', true)::jsonb->>'sub', '')::uuid;
$$;

COMMENT ON FUNCTION app_private.current_user_id IS 'Returns the authenticated user id (auth.uid()) or NULL.';

-- Enumerations
CREATE TYPE user_role AS ENUM ('admin', 'coordinator', 'professional', 'viewer');
CREATE TYPE shift_status AS ENUM ('scheduled', 'published', 'assigned', 'in_progress', 'completed', 'cancelled');
CREATE TYPE presence_state AS ENUM ('offline', 'online', 'on_break', 'unresponsive');
CREATE TYPE patient_status AS ENUM ('active', 'inactive', 'discharged', 'deceased');
CREATE TYPE supply_request_status AS ENUM ('pending', 'approved', 'denied', 'fulfilled', 'cancelled');

COMMENT ON TYPE user_role IS 'Application role assigned to a user within a tenant.';
COMMENT ON TYPE shift_status IS 'Lifecycle status of a shift (plantão).';
COMMENT ON TYPE presence_state IS 'Realtime presence state for professionals within a shift.';
COMMENT ON TYPE patient_status IS 'Administrative status for a patient record.';
COMMENT ON TYPE supply_request_status IS 'Workflow status for a supply / inventory request.';

-- Tenants
CREATE TABLE tenants (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name text NOT NULL,
  slug text NOT NULL UNIQUE,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

COMMENT ON TABLE tenants IS 'Organisational boundary for multitenant deployments.';
COMMENT ON COLUMN tenants.id IS 'Tenant primary key.';
COMMENT ON COLUMN tenants.name IS 'Tenant friendly name (clinic, franchise, etc).';
COMMENT ON COLUMN tenants.slug IS 'Lowercase unique slug for tenant routing.';
COMMENT ON COLUMN tenants.created_at IS 'Creation timestamp.';
COMMENT ON COLUMN tenants.updated_at IS 'Last update timestamp.';

-- Application user profile mapped to Supabase auth.users
CREATE TABLE app_users (
  id uuid PRIMARY KEY REFERENCES auth.users (id) ON DELETE CASCADE,
  tenant_id uuid REFERENCES tenants (id) ON DELETE SET NULL,
  email text NOT NULL UNIQUE,
  display_name text NOT NULL,
  phone_number text,
  role user_role NOT NULL DEFAULT 'viewer',
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

COMMENT ON TABLE app_users IS 'Application-level profile for each Supabase auth user.';
COMMENT ON COLUMN app_users.id IS 'Matches auth.users.id';
COMMENT ON COLUMN app_users.tenant_id IS 'Tenant that the user belongs to (if any).';
COMMENT ON COLUMN app_users.email IS 'Login email cached for quick access.';
COMMENT ON COLUMN app_users.display_name IS 'Display name for UI badges and logs.';
COMMENT ON COLUMN app_users.phone_number IS 'Optional phone for contact/escalation.';
COMMENT ON COLUMN app_users.role IS 'Role within the tenant for access control.';
COMMENT ON COLUMN app_users.created_at IS 'Creation timestamp.';
COMMENT ON COLUMN app_users.updated_at IS 'Last update timestamp.';

-- Patients
CREATE TABLE patients (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid REFERENCES tenants (id) ON DELETE CASCADE,
  full_name text NOT NULL,
  date_of_birth date,
  document_id text,
  gender text,
  contact_email text,
  contact_phone text,
  address jsonb,
  clinical_summary jsonb,
  status patient_status NOT NULL DEFAULT 'active',
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

COMMENT ON TABLE patients IS 'Patient master data, including contact and clinical summary metadata.';
COMMENT ON COLUMN patients.id IS 'Patient identifier (UUID).';
COMMENT ON COLUMN patients.tenant_id IS 'Tenant to which the patient belongs.';
COMMENT ON COLUMN patients.full_name IS 'Full legal name.';
COMMENT ON COLUMN patients.date_of_birth IS 'Date of birth (UTC).';
COMMENT ON COLUMN patients.document_id IS 'Primary national identifier (CPF/CNS etc).';
COMMENT ON COLUMN patients.gender IS 'Gender/identity descriptor.';
COMMENT ON COLUMN patients.contact_email IS 'Primary email for notifications.';
COMMENT ON COLUMN patients.contact_phone IS 'Primary phone / WhatsApp contact.';
COMMENT ON COLUMN patients.address IS 'Structured address + geo data (JSON).';
COMMENT ON COLUMN patients.clinical_summary IS 'High-level clinical summary (JSON).';
COMMENT ON COLUMN patients.status IS 'Administrative status (active, discharged etc).';
COMMENT ON COLUMN patients.created_at IS 'Creation timestamp.';
COMMENT ON COLUMN patients.updated_at IS 'Last update timestamp.';

-- Professionals
CREATE TABLE professionals (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid REFERENCES tenants (id) ON DELETE CASCADE,
  full_name text NOT NULL,
  registry_code text,
  specialties text[] NOT NULL DEFAULT ARRAY[]::text[],
  phone text,
  email text,
  avatar_url text,
  notes text,
  employment_type text,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

COMMENT ON TABLE professionals IS 'Care professionals attached to the tenant.';
COMMENT ON COLUMN professionals.registry_code IS 'Professional registry (COREN, CRM etc).';
COMMENT ON COLUMN professionals.specialties IS 'Array of specialties.';
COMMENT ON COLUMN professionals.employment_type IS 'Contract type (internal, external, etc).';

-- Shifts
CREATE TABLE shifts (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid REFERENCES tenants (id) ON DELETE CASCADE,
  patient_id uuid REFERENCES patients (id) ON DELETE SET NULL,
  professional_id uuid REFERENCES professionals (id) ON DELETE SET NULL,
  created_by_id uuid NOT NULL REFERENCES app_users (id) ON DELETE RESTRICT,
  title text NOT NULL,
  description text,
  start_at timestamptz NOT NULL,
  end_at timestamptz NOT NULL,
  status shift_status NOT NULL DEFAULT 'scheduled',
  location jsonb,
  meta jsonb,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX idx_shifts_tenant_start ON shifts (tenant_id, start_at);
CREATE INDEX idx_shifts_status ON shifts (status);

COMMENT ON TABLE shifts IS 'Scheduled plantões for patients, linked to professionals.';
COMMENT ON COLUMN shifts.created_by_id IS 'User who created the shift.';
COMMENT ON COLUMN shifts.status IS 'Lifecycle state of the shift.';
COMMENT ON COLUMN shifts.location IS 'Optional geo/route information.';
COMMENT ON COLUMN shifts.meta IS 'Additional shift metadata (JSON).';

-- Posts (shift feed)
CREATE TABLE shift_posts (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid REFERENCES tenants (id) ON DELETE CASCADE,
  shift_id uuid NOT NULL REFERENCES shifts (id) ON DELETE CASCADE,
  author_id uuid NOT NULL REFERENCES app_users (id) ON DELETE SET NULL,
  content text NOT NULL,
  pinned boolean NOT NULL DEFAULT false,
  attachments jsonb,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX idx_posts_shift_created ON shift_posts (shift_id, created_at DESC);

COMMENT ON TABLE shift_posts IS 'Realtime post stream for coordination inside a shift.';
COMMENT ON COLUMN shift_posts.attachments IS 'Optional attachment metadata (files, media).';

-- Presence
CREATE TABLE shift_presence (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid REFERENCES tenants (id) ON DELETE CASCADE,
  shift_id uuid NOT NULL REFERENCES shifts (id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES app_users (id) ON DELETE CASCADE,
  professional_id uuid REFERENCES professionals (id) ON DELETE SET NULL,
  state presence_state NOT NULL DEFAULT 'offline',
  last_seen timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX idx_presence_shift_user ON shift_presence (shift_id, user_id);

COMMENT ON TABLE shift_presence IS 'Presence state of users in a shift.';

-- Inventory
CREATE TABLE inventory_items (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid REFERENCES tenants (id) ON DELETE CASCADE,
  sku text NOT NULL,
  name text NOT NULL,
  description text,
  unit text,
  quantity integer NOT NULL DEFAULT 0,
  threshold integer NOT NULL DEFAULT 0,
  location text,
  meta jsonb,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE UNIQUE INDEX idx_inventory_tenant_sku ON inventory_items (tenant_id, sku);

COMMENT ON TABLE inventory_items IS 'Inventory catalog of consumables and assets.';

-- Supply requests
CREATE TABLE supply_requests (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid REFERENCES tenants (id) ON DELETE CASCADE,
  patient_id uuid REFERENCES patients (id) ON DELETE SET NULL,
  requested_by uuid REFERENCES app_users (id) ON DELETE SET NULL,
  item_id uuid REFERENCES inventory_items (id) ON DELETE SET NULL,
  status supply_request_status NOT NULL DEFAULT 'pending',
  notes text,
  quantity integer NOT NULL DEFAULT 1,
  due_at timestamptz,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX idx_supply_requests_patient ON supply_requests (tenant_id, patient_id);

COMMENT ON TABLE supply_requests IS 'Workflow for requesting inventory replenishment.';

-- Audit logs
CREATE TABLE audit_logs (
  id bigserial PRIMARY KEY,
  tenant_id uuid REFERENCES tenants (id) ON DELETE SET NULL,
  entity text NOT NULL,
  entity_id text,
  action text NOT NULL,
  actor_id uuid REFERENCES app_users (id) ON DELETE SET NULL,
  context jsonb,
  payload jsonb,
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX idx_audit_entity ON audit_logs (tenant_id, entity, created_at DESC);

COMMENT ON TABLE audit_logs IS 'Immutable audit trail for create/update/delete operations and sensitive access.';

-- Updated_at trigger helper
CREATE OR REPLACE FUNCTION app_private.touch_updated_at()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

COMMENT ON FUNCTION app_private.touch_updated_at IS 'Keeps the updated_at column in sync.';

-- Attach triggers for updated_at
CREATE TRIGGER trg_touch_tenants BEFORE UPDATE ON tenants
  FOR EACH ROW EXECUTE FUNCTION app_private.touch_updated_at();

CREATE TRIGGER trg_touch_app_users BEFORE UPDATE ON app_users
  FOR EACH ROW EXECUTE FUNCTION app_private.touch_updated_at();

CREATE TRIGGER trg_touch_patients BEFORE UPDATE ON patients
  FOR EACH ROW EXECUTE FUNCTION app_private.touch_updated_at();

CREATE TRIGGER trg_touch_professionals BEFORE UPDATE ON professionals
  FOR EACH ROW EXECUTE FUNCTION app_private.touch_updated_at();

CREATE TRIGGER trg_touch_shifts BEFORE UPDATE ON shifts
  FOR EACH ROW EXECUTE FUNCTION app_private.touch_updated_at();

CREATE TRIGGER trg_touch_shift_posts BEFORE UPDATE ON shift_posts
  FOR EACH ROW EXECUTE FUNCTION app_private.touch_updated_at();

CREATE TRIGGER trg_touch_shift_presence BEFORE UPDATE ON shift_presence
  FOR EACH ROW EXECUTE FUNCTION app_private.touch_updated_at();

CREATE TRIGGER trg_touch_inventory BEFORE UPDATE ON inventory_items
  FOR EACH ROW EXECUTE FUNCTION app_private.touch_updated_at();

CREATE TRIGGER trg_touch_supply_requests BEFORE UPDATE ON supply_requests
  FOR EACH ROW EXECUTE FUNCTION app_private.touch_updated_at();

-- Audit trigger
CREATE OR REPLACE FUNCTION app_private.log_audit()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_user uuid := app_private.current_user_id();
  v_tenant uuid := app_private.current_tenant_id();
  v_json jsonb;
  v_entity_id text;
BEGIN
  IF TG_OP = 'DELETE' THEN
    v_json := to_jsonb(OLD);
    v_entity_id := COALESCE(OLD.id::text, OLD.entity_id::text);
  ELSE
    v_json := to_jsonb(NEW);
    v_entity_id := COALESCE(NEW.id::text, NEW.entity_id::text);
  END IF;

  INSERT INTO audit_logs (tenant_id, entity, entity_id, action, actor_id, context, payload, created_at)
  VALUES (
    COALESCE(v_tenant, v_json->>'tenant_id')::uuid,
    TG_TABLE_NAME,
    v_entity_id,
    TG_OP,
    v_user,
    jsonb_build_object('schema', TG_TABLE_SCHEMA),
    v_json,
    now()
  );

  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  ELSE
    RETURN NEW;
  END IF;
END;
$$;

COMMENT ON FUNCTION app_private.log_audit IS 'Generic trigger to write row-level audit events.';

-- Attach audit triggers to critical tables
CREATE TRIGGER trg_audit_shifts
  AFTER INSERT OR UPDATE OR DELETE ON shifts
  FOR EACH ROW EXECUTE FUNCTION app_private.log_audit();

CREATE TRIGGER trg_audit_shift_posts
  AFTER INSERT OR UPDATE OR DELETE ON shift_posts
  FOR EACH ROW EXECUTE FUNCTION app_private.log_audit();

CREATE TRIGGER trg_audit_shift_presence
  AFTER INSERT OR UPDATE OR DELETE ON shift_presence
  FOR EACH ROW EXECUTE FUNCTION app_private.log_audit();

CREATE TRIGGER trg_audit_patients
  AFTER INSERT OR UPDATE OR DELETE ON patients
  FOR EACH ROW EXECUTE FUNCTION app_private.log_audit();

CREATE TRIGGER trg_audit_supply_requests
  AFTER INSERT OR UPDATE OR DELETE ON supply_requests
  FOR EACH ROW EXECUTE FUNCTION app_private.log_audit();

-- END 000_init.sql

-- BEGIN 001_security_realtime.sql (selected parts)
ALTER TABLE IF EXISTS tenants ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS app_users ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS patients ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS professionals ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS shifts ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS shift_posts ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS shift_presence ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS inventory_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS supply_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS audit_logs ENABLE ROW LEVEL SECURITY;

-- Drop and recreate policies (abbreviated, see sql/001_security_realtime.sql for details)
DROP POLICY IF EXISTS tenant_admin_manage ON tenants;
DROP POLICY IF EXISTS tenant_member_read ON tenants;
CREATE POLICY tenant_admin_manage ON tenants FOR ALL USING (app_private.current_app_role() = 'admin') WITH CHECK (app_private.current_app_role() = 'admin');
CREATE POLICY tenant_member_read ON tenants FOR SELECT USING (id = app_private.current_tenant_id() OR app_private.current_app_role() = 'admin');

DROP POLICY IF EXISTS users_self_select ON app_users;
DROP POLICY IF EXISTS users_manage_admin ON app_users;
CREATE POLICY users_self_select ON app_users FOR SELECT USING (id = app_private.current_user_id() OR app_private.current_app_role() IN ('admin','coordinator'));
CREATE POLICY users_manage_admin ON app_users FOR ALL USING (app_private.current_app_role() = 'admin' AND (tenant_id IS NULL OR tenant_id = app_private.current_tenant_id())) WITH CHECK (app_private.current_app_role() = 'admin' AND (tenant_id IS NULL OR tenant_id = app_private.current_tenant_id()));

DROP POLICY IF EXISTS patients_select_same_tenant ON patients;
DROP POLICY IF EXISTS patients_write_roles ON patients;
DROP POLICY IF EXISTS patients_update_roles ON patients;
CREATE POLICY patients_select_same_tenant ON patients FOR SELECT USING (tenant_id = app_private.current_tenant_id());
CREATE POLICY patients_write_roles ON patients FOR INSERT WITH CHECK (tenant_id = app_private.current_tenant_id() AND app_private.current_app_role() IN ('admin','coordinator'));
CREATE POLICY patients_update_roles ON patients FOR UPDATE USING (tenant_id = app_private.current_tenant_id() AND app_private.current_app_role() IN ('admin','coordinator'));

DROP POLICY IF EXISTS professionals_select_same_tenant ON professionals;
DROP POLICY IF EXISTS professionals_manage_admin ON professionals;
CREATE POLICY professionals_select_same_tenant ON professionals FOR SELECT USING (tenant_id = app_private.current_tenant_id());
CREATE POLICY professionals_manage_admin ON professionals FOR ALL USING (tenant_id = app_private.current_tenant_id() AND app_private.current_app_role() IN ('admin','coordinator')) WITH CHECK (tenant_id = app_private.current_tenant_id() AND app_private.current_app_role() IN ('admin','coordinator'));

DROP POLICY IF EXISTS shifts_select_same_tenant ON shifts;
DROP POLICY IF EXISTS shifts_insert_roles ON shifts;
DROP POLICY IF EXISTS shifts_update_roles ON shifts;
CREATE POLICY shifts_select_same_tenant ON shifts FOR SELECT USING (tenant_id = app_private.current_tenant_id());
CREATE POLICY shifts_insert_roles ON shifts FOR INSERT WITH CHECK (tenant_id = app_private.current_tenant_id() AND app_private.current_app_role() IN ('admin','coordinator'));
CREATE POLICY shifts_update_roles ON shifts FOR UPDATE USING (tenant_id = app_private.current_tenant_id() AND app_private.current_app_role() IN ('admin','coordinator'));

DROP POLICY IF EXISTS posts_select_shift_members ON shift_posts;
DROP POLICY IF EXISTS posts_insert_members ON shift_posts;
DROP POLICY IF EXISTS posts_update_author_or_admin ON shift_posts;
CREATE POLICY posts_select_shift_members ON shift_posts FOR SELECT USING (tenant_id = app_private.current_tenant_id() AND EXISTS (SELECT 1 FROM shifts s WHERE s.id = shift_posts.shift_id AND s.tenant_id = app_private.current_tenant_id()));
CREATE POLICY posts_insert_members ON shift_posts FOR INSERT WITH CHECK (tenant_id = app_private.current_tenant_id() AND author_id = app_private.current_user_id() AND app_private.current_app_role() IN ('admin','coordinator','professional'));
CREATE POLICY posts_update_author_or_admin ON shift_posts FOR UPDATE USING (tenant_id = app_private.current_tenant_id() AND (author_id = app_private.current_user_id() OR app_private.current_app_role() IN ('admin','coordinator')));

DROP POLICY IF EXISTS presence_select_shift_members ON shift_presence;
DROP POLICY IF EXISTS presence_upsert_self ON shift_presence;
DROP POLICY IF EXISTS presence_admin_manage ON shift_presence;
CREATE POLICY presence_select_shift_members ON shift_presence FOR SELECT USING (tenant_id = app_private.current_tenant_id());
CREATE POLICY presence_upsert_self ON shift_presence FOR ALL USING (tenant_id = app_private.current_tenant_id() AND user_id = app_private.current_user_id()) WITH CHECK (tenant_id = app_private.current_tenant_id() AND user_id = app_private.current_user_id());
CREATE POLICY presence_admin_manage ON shift_presence FOR ALL USING (tenant_id = app_private.current_tenant_id() AND app_private.current_app_role() IN ('admin','coordinator')) WITH CHECK (tenant_id = app_private.current_tenant_id() AND app_private.current_app_role() IN ('admin','coordinator'));

DROP POLICY IF EXISTS inventory_select_same_tenant ON inventory_items;
DROP POLICY IF EXISTS inventory_manage_roles ON inventory_items;
CREATE POLICY inventory_select_same_tenant ON inventory_items FOR SELECT USING (tenant_id = app_private.current_tenant_id());
CREATE POLICY inventory_manage_roles ON inventory_items FOR ALL USING (tenant_id = app_private.current_tenant_id() AND app_private.current_app_role() IN ('admin','coordinator')) WITH CHECK (tenant_id = app_private.current_tenant_id() AND app_private.current_app_role() IN ('admin','coordinator'));

DROP POLICY IF EXISTS supply_select_same_tenant ON supply_requests;
DROP POLICY IF EXISTS supply_insert_members ON supply_requests;
DROP POLICY IF EXISTS supply_update_admin ON supply_requests;
CREATE POLICY supply_select_same_tenant ON supply_requests FOR SELECT USING (tenant_id = app_private.current_tenant_id());
CREATE POLICY supply_insert_members ON supply_requests FOR INSERT WITH CHECK (tenant_id = app_private.current_tenant_id() AND app_private.current_app_role() IN ('admin','coordinator','professional'));
CREATE POLICY supply_update_admin ON supply_requests FOR UPDATE USING (tenant_id = app_private.current_tenant_id() AND app_private.current_app_role() IN ('admin','coordinator'));

DROP POLICY IF EXISTS audit_select_admin ON audit_logs;
CREATE POLICY audit_select_admin ON audit_logs FOR SELECT USING (app_private.current_app_role() = 'admin');
-- END 001_security_realtime.sql

-- BEGIN 002_trigger_user_profiles.sql
create or replace function public.handle_new_auth_user()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  insert into public.user_profiles (auth_user_id, email, name, role, tenant_id)
  values (
    new.id,
    new.email,
    coalesce(new.raw_user_meta_data->>'name',''),
    coalesce(new.raw_user_meta_data->>'role', 'viewer'),
    null
  )
  on conflict (auth_user_id)
  do update set
    email = excluded.email,
    name = excluded.name;
  return new;
end;
$$;

drop trigger if exists on_auth_user_created on auth.users;

create trigger on_auth_user_created
after insert on auth.users
for each row
execute function public.handle_new_auth_user();
-- END 002_trigger_user_profiles.sql


